<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Coherence Multiverse</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            line-height: 1.5;
            max-width: 80%;
            z-index: 10; /* Ensure it's above the canvas */
        }
        #info-title { font-weight: 700; font-size: 22px; color: #ffdf80; }
        #info-description { font-size: 16px; color: #ccc; }

        .back-link {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            text-decoration: none;
            font-family: 'Inter', sans-serif;
            z-index: 10; /* Ensure it's above the canvas */
        }
        .back-link:hover {
            background-color: rgba(0, 0, 0, 0.8);
            border-color: #fff;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info-panel">
        <div id="info-title">Phase I: Initial State</div>
        <div id="info-description">A high population of universe bubbles in a state of potential.</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Simulation Parameters ---
        const NUM_UNIVERSES = 100000; // A large number for "high population"
        const FIELD_SPREAD = 200;    // Initial spread of universes
        const TORUS_MAJOR_RADIUS = 80; // Radius from center of hole to center of tube
        const TORUS_MINOR_RADIUS = 30; // Radius of the tube itself
        const ASYMPTOTIC_FLOAT_ACTIVATION_TIME = 5.0; // Seconds into simulation
        const COHERENCE_CASCADE_DURATION = 10.0; // How long the formation takes after float activation

        // --- Wild Asymptotic Float Parameters ---
        // This version of the float will fluctuate wildly between 0.01 and 0.9 and never settle.
        const WILD_FLOAT_BASE_OSCILLATION_CENTER = 0.5; // Center of the base value fluctuation
        const WILD_FLOAT_BASE_OSCILLATION_AMPLITUDE = 0.4; // Amplitude of base value fluctuation (0.5 +/- 0.4 = 0.1 to 0.9)
        const WILD_FLOAT_BASE_OSCILLATION_SPEED = 0.5; // Speed of the base oscillation
        const WILD_FLOAT_CHAOS_AMPLITUDE = 0.4; // How strong the chaotic cosine term is

        // --- Scene & Simulation State ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 200); // Adjust camera to view the torus
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;
        controls.minDistance = 50;
        controls.maxDistance = 500;

        const clock = new THREE.Clock();
       
        // --- Particle System Setup ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(NUM_UNIVERSES * 3);
        const colors = new Float32Array(NUM_UNIVERSES * 3);
        // Stores: [initialPos, targetPos, reality_val, prev_reality_val]
        const universeStates = [];

        // --- Fibonacci Function (used for chaos frequency in wild float) ---
        const fibonacciCache = { 0: 0, 1: 1 };
        function getFibonacci(n) {
            if (fibonacciCache[n] !== undefined) {
                return fibonacciCache[n];
            }
            if (n > 40) { // Cap at a large but manageable value for frequency scaling
                return fibonacciCache[40];
            }
            fibonacciCache[n] = getFibonacci(n - 1) + getFibonacci(n - 2);
            return fibonacciCache[n];
        }

        // --- Initialize Universe Bubbles ---
        for (let i = 0; i < NUM_UNIVERSES; i++) {
            // Initial random spread
            const initialX = (Math.random() - 0.5) * FIELD_SPREAD;
            const initialY = (Math.random() - 0.5) * FIELD_SPREAD;
            const initialZ = (Math.random() - 0.5) * FIELD_SPREAD;

            // Calculate target position on the torus
            const u = Math.random() * Math.PI * 2; // Angle around the main ring
            const v = Math.random() * Math.PI * 2; // Angle around the tube

            const targetX = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(v)) * Math.cos(u);
            const targetY = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(v)) * Math.sin(u);
            const targetZ = TORUS_MINOR_RADIUS * Math.sin(v);

            positions[i * 3] = initialX;
            positions[i * 3 + 1] = initialY;
            positions[i * 3 + 2] = initialZ;

            universeStates.push({
                initialPos: new THREE.Vector3(initialX, initialY, initialZ),
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                reality_val: Math.random() * 0.2, // Initial low reality value
                prev_reality_val: Math.random() * 0.2 // Initial low prev reality value
            });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.8, // Slightly larger points for visibility
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- Narrative & State Management ---
        const infoTitle = document.getElementById('info-title');
        const infoDescription = document.getElementById('info-description');
        let currentPhase = 0; // 0: Initial, 1: Wild Asymptotic Float Active (Cascading), 2: Wildly Coherent

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const elapsedTime = clock.getElapsedTime();
            const currentDiscreteTimeStep = Math.floor(elapsedTime); // For F_t calculation

            const currentPositions = geometry.attributes.position.array;
            const currentColors = geometry.attributes.color.array;
            const color = new THREE.Color();

            // --- Update Simulation Phase ---
            if (elapsedTime >= ASYMPTOTIC_FLOAT_ACTIVATION_TIME && currentPhase === 0) {
                currentPhase = 1; // Wild Asymptotic Float activates, start cascade
                infoTitle.textContent = 'Phase II: Wild Asymptotic Float Activates';
                infoDescription.textContent = 'The fundamental algorithm awakens, but its chaotic nature prevents stable order.';
            } else if (elapsedTime >= ASYMPTOTIC_FLOAT_ACTIVATION_TIME + COHERENCE_CASCADE_DURATION && currentPhase === 1) {
                currentPhase = 2; // Wildly Coherent
                infoTitle.textContent = 'Phase III: Unsettled Multiverse';
                infoDescription.textContent = 'The multiverse is active, but perpetually fluctuating and unable to achieve profound, stable order.';
                controls.autoRotateSpeed = 0.05; // Slow down auto-rotation, but still show movement
            }

            // --- Update each Universe Bubble ---
            for (let i = 0; i < NUM_UNIVERSES; i++) {
                const state = universeStates[i];
                let currentPos = new THREE.Vector3(currentPositions[i * 3], currentPositions[i * 3 + 1], currentPositions[i * 3 + 2]);

                // Store current reality_val as prev_reality_val for next iteration
                state.prev_reality_val = state.reality_val;

                let coherenceFactor = 0; // Used for visual interpolation and coloring

                if (currentPhase === 0) { // Initial State - Random drift, no strong coherence
                    currentPos.x += (Math.random() - 0.5) * 0.1;
                    currentPos.y += (Math.random() - 0.5) * 0.1;
                    currentPos.z += (Math.random() - 0.5) * 0.1;
                    state.reality_val = THREE.MathUtils.lerp(state.reality_val, Math.random() * 0.2, 0.01);
                    coherenceFactor = 0; // Low coherence visually
                } else if (currentPhase === 1 || currentPhase === 2) { // Wild Asymptotic Float Active
                    const Ft = getFibonacci(currentDiscreteTimeStep - ASYMPTOTIC_FLOAT_ACTIVATION_TIME + 2); // Time relative to activation

                    // --- WILD ASYMPTOTIC FLOAT EQUATION ---
                    // V_t = (WILD_FLOAT_BASE_OSCILLATION) + (cos(pi * V_t-1 * F_t) * WILD_FLOAT_CHAOS_AMPLITUDE);
                    const baseValue = WILD_FLOAT_BASE_OSCILLATION_CENTER + WILD_FLOAT_BASE_OSCILLATION_AMPLITUDE * Math.sin(elapsedTime * WILD_FLOAT_BASE_OSCILLATION_SPEED);
                    state.reality_val = baseValue + (Math.cos(Math.PI * state.prev_reality_val * Ft) * WILD_FLOAT_CHAOS_AMPLITUDE);
                    
                    // Ensure reality_val stays within the desired wild fluctuation range [0.01, 0.9]
                    state.reality_val = Math.max(0.01, Math.min(0.9, state.reality_val));

                    // The coherence factor for movement and color is now directly linked to the fluctuating reality_val
                    coherenceFactor = state.reality_val;

                    // Blend movement based on the fluctuating reality_val.
                    // This will make particles struggle to reach and maintain the torus shape.
                    const targetProgress = (coherenceFactor - 0.01) / (0.9 - 0.01); // Normalize 0.01-0.9 to 0-1
                    currentPos.lerpVectors(state.initialPos, state.targetPos, targetProgress);

                    // Add subtle breathing/pulsing effect based on float's chaotic term
                    const pulse = Math.sin(state.reality_val * Math.PI * 5 + elapsedTime * 0.5) * 0.05;
                    currentPos.addScaledVector(currentPos.clone().normalize(), pulse);
                }

                currentPositions[i * 3] = currentPos.x;
                currentPositions[i * 3 + 1] = currentPos.y;
                currentPositions[i * 3 + 2] = currentPos.z;

                // --- Set Color based on Coherence Factor ---
                // Interpolate from a cool blue/purple to a warm golden/white, but now reflecting the wild fluctuations
                const hueStart = 0.6; // Blue
                const hueEnd = 0.12;  // Golden
                const saturationStart = 0.8;
                const saturationEnd = 1.0;
                const lightnessStart = 0.1;
                const lightnessEnd = 0.9;

                const currentHue = THREE.MathUtils.lerp(hueStart, hueEnd, coherenceFactor);
                const currentSaturation = THREE.MathUtils.lerp(saturationStart, saturationEnd, coherenceFactor);
                const currentLightness = THREE.MathUtils.lerp(lightnessStart, lightnessEnd, coherenceFactor);
               
                color.setHSL(currentHue, currentSaturation, currentLightness);

                currentColors[i * 3] = color.r;
                currentColors[i * 3 + 1] = color.g;
                currentColors[i * 3 + 2] = color.b;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- Handle Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Add Back Button ---
        const backButton = document.createElement('a');
        backButton.href = 'index.html';
        backButton.textContent = 'Back to Index';
        backButton.className = 'back-link'; // Use a class for styling
        document.body.appendChild(backButton);
       
        // Start the animation
        animate();
    </script>
</body>
</html>
