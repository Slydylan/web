<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Genesis Field</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            border-radius: 10px;
            text-align: center;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .control-group {
            text-align: left;
        }
        label {
            display: block;
            font-size: 14px;
            margin-bottom: 5px;
            color: #ccc;
        }
        input[type="range"] {
            width: 150px;
        }
        #title-panel {
            position: absolute;
            top: 20px;
            left: 20px;
        }
        h1 { font-size: 2em; margin: 0; font-weight: 300; letter-spacing: 2px; }
        p { font-size: 0.9em; margin: 5px 0 0 0; color: #aaa; font-style: italic; }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300&display=swap" rel="stylesheet">
</head>
<body>
    <div id="title-panel">
        <h1>The Genesis Field</h1>
        <p>A simulation of a state-based reality.</p>
    </div>

    <div id="controls">
        <div class="control-group">
            <label for="omega-slider">Baseline Coherence (&omega;)</label>
            <input type="range" id="omega-slider" min="0.1" max="0.9" value="0.45" step="0.01">
        </div>
        <div class="control-group">
            <label for="variance-slider">Field Variance</label>
            <input type="range" id="variance-slider" min="1.0" max="15.0" value="5.0" step="0.1">
        </div>
        <div class="control-group">
            <label for="time-slider">Landscape (W-axis)</label>
            <input type="range" id="time-slider" min="0.0" max="100.0" value="10.0" step="0.1">
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 150);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;

        // --- Simulation Parameters ---
        const PARTICLE_COUNT = 200000;
        const FIELD_EXTENT = 200;

        // --- Particle System Setup ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const internalOmegas = new Float32Array(PARTICLE_COUNT); // Each particle's "personality"

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3 + 0] = (Math.random() - 0.5) * FIELD_EXTENT;
            positions[i * 3 + 1] = (Math.random() - 0.5) * FIELD_EXTENT;
            positions[i * 3 + 2] = (Math.random() - 0.5) * FIELD_EXTENT;
            internalOmegas[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('internalOmega', new THREE.BufferAttribute(internalOmegas, 1));

        // --- Shader Material: The Core of the New Model ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { value: 0.0 },
                u_field_extent: { value: FIELD_EXTENT },
                u_baseline_omega: { value: 0.45 },
                u_field_variance: { value: 5.0 },
                u_w_axis: { value: 10.0 },
            },
            vertexShader: `
                uniform float u_time;
                uniform float u_field_extent;
                uniform float u_baseline_omega;
                uniform float u_field_variance;
                uniform float u_w_axis;

                attribute float internalOmega;

                varying float v_chi;   // Chaotic Potential
                varying float v_sigma; // Structural Information

                // --- Constants for the Elegant Raw Model ---
                const float PI = 3.14159265359;
                const float PHI = 1.61803398875;

                // --- 4D Simplex Noise Function (for procedural field) ---
                // Author: Ian McEwan, Ashima Arts. License: MIT.
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                float permute(float x) { return mod289(((x*34.0)+1.0)*x); }
                
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                // --- FIX: Added float overload for taylorInvSqrt ---
                float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }


                vec4 grad4(float j, vec4 ip) {
                    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
                    vec4 p,s;
                    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
                    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
                    s = vec4(lessThan(p, vec4(0.0)));
                    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
                    return p;
                }

                float snoise(vec4 v) {
                    const vec2 C = vec2(0.1381966011250105, 0.3090169943749475);
                    vec4 i  = floor(v + dot(v, C.yyyy) );
                    vec4 x0 = v - i + dot(i, C.xxxx);

                    vec4 i0;
                    vec3 isX = step( x0.yzw, x0.xxx );
                    vec3 isYZ = step( x0.zww, x0.yyz );
                    i0.x = isX.x + isX.y + isX.z;
                    i0.yzw = 1.0 - isX;
                    i0.y += isYZ.x + isYZ.y;
                    i0.zw += 1.0 - isYZ.xy;
                    i0.z += isYZ.z;
                    i0.w += 1.0 - isYZ.z;

                    vec4 i3 = clamp( i0, 0.0, 1.0 );
                    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
                    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

                    vec4 x1 = x0 - i1 + C.xxxx;
                    vec4 x2 = x0 - i2 + C.yyyy;
                    vec4 x3 = x0 - i3 + 0.5;
                    vec4 x4 = x0 - 1.0 + 0.75;

                    i = mod289(i);
                    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
                    vec4 j1 = permute( permute( permute( permute (
                                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

                    const vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

                    vec4 p0 = grad4(j0,   ip);
                    vec4 p1 = grad4(j1.x, ip);
                    vec4 p2 = grad4(j1.y, ip);
                    vec4 p3 = grad4(j1.z, ip);
                    vec4 p4 = grad4(j1.w, ip);

                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                    p4 *= taylorInvSqrt(dot(p4,p4));

                    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
                    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);
                    m0 = m0 * m0;
                    m1 = m1 * m1;
                    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) )) ) ;
                }
                
                // Function to get the procedural omega value at any point
                float getFieldOmega(vec3 pos) {
                    vec4 coord = vec4(pos / u_field_extent * u_field_variance, u_w_axis);
                    float noise = snoise(coord); // range -1 to 1
                    return u_baseline_omega + (noise * (1.0 - u_baseline_omega));
                }

                void main() {
                    // 1. Determine Total Coherence (ω)
                    float fieldOmega = getFieldOmega(position);
                    float totalOmega = mix(fieldOmega, internalOmega, 0.5);
                    totalOmega = clamp(totalOmega, 0.01, 0.99);

                    // 2. Calculate Duality Vectors for Hyperdimensional Motion
                    vec3 pos = position;
                    float step = 5.0; // How far to look for the gradient

                    // Coherence Vector (drive to order)
                    float omega_x = getFieldOmega(pos + vec3(step, 0, 0));
                    float omega_y = getFieldOmega(pos + vec3(0, step, 0));
                    float omega_z = getFieldOmega(pos + vec3(0, 0, step));
                    vec3 coherenceVec = normalize(vec3(omega_x, omega_y, omega_z) - fieldOmega);

                    // Chaos Vector (drive to novelty)
                    vec3 chaosVec = normalize(vec3(
                        snoise(vec4(pos.xyz * 0.1, u_time * 0.1)),
                        snoise(vec4(pos.yzx * 0.1, u_time * 0.1)),
                        snoise(vec4(pos.zxy * 0.1, u_time * 0.1))
                    ));

                    // 3. Blend vectors based on coherence
                    vec3 moveDir = mix(chaosVec, coherenceVec, totalOmega * totalOmega);
                    vec3 newPos = pos + moveDir * 2.0; // The "jump"

                    // Keep particles within bounds
                    if (length(newPos) > u_field_extent * 1.5) {
                        newPos = -newPos * 0.9;
                    }
                    
                    // 4. Calculate Duality Principles for Visuals
                    v_chi = PHI / (PI * totalOmega);
                    v_sigma = totalOmega * (PI / PHI);

                    // 5. Set final position and size
                    vec4 modelViewPosition = modelViewMatrix * vec4(newPos, 1.0);
                    gl_Position = projectionMatrix * modelViewPosition;
                    gl_PointSize = v_sigma * v_sigma * 15.0;
                }
            `,
            fragmentShader: `
                varying float v_chi;
                varying float v_sigma;

                // --- HSL to RGB conversion ---
                vec3 hsl2rgb(vec3 c) {
                    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
                    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
                }

                void main() {
                    // Color is driven by Chaotic Potential (χ)
                    float hue = 0.6 - (1.0 / (v_chi * v_chi)) * 0.5; // High chaos -> Blue/Purple, Low chaos -> Red/Yellow
                    float lightness = clamp(pow(v_chi, 2.0) * 0.1, 0.2, 1.0);
                    float saturation = 1.0;
                    
                    vec3 color = hsl2rgb(vec3(hue, saturation, lightness));

                    // Fade out at edges
                    float dist = distance(gl_PointCoord, vec2(0.5));
                    float alpha = 1.0 - smoothstep(0.4, 0.5, dist);

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- UI Listeners ---
        const omegaSlider = document.getElementById('omega-slider');
        const varianceSlider = document.getElementById('variance-slider');
        const timeSlider = document.getElementById('time-slider');

        omegaSlider.addEventListener('input', (e) => material.uniforms.u_baseline_omega.value = parseFloat(e.target.value));
        varianceSlider.addEventListener('input', (e) => material.uniforms.u_field_variance.value = parseFloat(e.target.value));
        timeSlider.addEventListener('input', (e) => material.uniforms.u_w_axis.value = parseFloat(e.target.value));

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = performance.now() / 1000;
            material.uniforms.u_time.value = elapsedTime;
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
