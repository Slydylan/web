<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Omega Field: A State-Based Reality</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            max-width: 300px;
        }
        #title {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 0 15px #ff80ff;
            margin: 0 0 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        #info {
            font-size: 12px;
            color: #aaa;
            margin-top: 15px;
            line-height: 1.5;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300&display=swap" rel="stylesheet">
</head>
<body>
    <div id="ui-container">
        <h1 id="title">The Omega Field</h1>
        <label for="drive-slider">Omega Drive Level (Fn): <span id="drive-value">8</span></label>
        <input type="range" id="drive-slider" min="3" max="15" value="8" step="1">
        <div id="info">
            Move your mouse to apply coherence (ω) to the field. <br>
            Higher coherence creates structure (Σ).<br>
            Lower coherence reveals chaotic potential (χ).
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Core Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 1.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.5;
        controls.maxDistance = 5;

        // --- UI Interaction ---
        const driveSlider = document.getElementById('drive-slider');
        const driveValueSpan = document.getElementById('drive-value');
        
        // Pre-calculate Fibonacci numbers for efficiency
        const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610];

        let omegaDriveLevel = fibonacci[parseInt(driveSlider.value)];
        driveValueSpan.textContent = driveSlider.value;

        driveSlider.addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            omegaDriveLevel = fibonacci[index];
            driveValueSpan.textContent = index;
            if(shaderMaterial) {
                shaderMaterial.uniforms.u_omega_drive.value = omegaDriveLevel;
            }
        });

        // --- State-Based Reality Simulation ---
        // We now use a 3D texture to represent the Omega Field's coherence (ω)
        const fieldResolution = 64;
        const data = new Float32Array(fieldResolution * fieldResolution * fieldResolution);
        const coherenceTexture = new THREE.Data3DTexture(data, fieldResolution, fieldResolution, fieldResolution);
        coherenceTexture.format = THREE.RedFormat;
        coherenceTexture.type = THREE.FloatType;
        coherenceTexture.minFilter = THREE.LinearFilter;
        coherenceTexture.magFilter = THREE.LinearFilter;
        coherenceTexture.unpackAlignment = 1;
        coherenceTexture.needsUpdate = true;

        // --- Mouse Interaction to manipulate ω ---
        const mouse = new THREE.Vector2(-10, -10); // Start off-screen
        const lastMouse = new THREE.Vector2(-10, -10);
        let isMouseDown = false;
        
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => { isMouseDown = true; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });
        window.addEventListener('mouseout', () => { mouse.set(-10, -10); }); // Move off-screen on mouse out

        // --- Ray Marching Shader (The New Renderer) ---
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { value: 0.0 },
                u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                u_camera_pos: { value: camera.position },
                u_camera_view_matrix: { value: camera.matrixWorldInverse },
                u_camera_proj_matrix: { value: camera.projectionMatrix },
                u_coherence_field: { value: coherenceTexture },
                u_omega_drive: { value: omegaDriveLevel },
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                precision highp float;
                precision highp sampler3D;

                uniform vec2 u_resolution;
                uniform float u_time;
                uniform mat4 u_camera_view_matrix;
                uniform mat4 u_camera_proj_matrix;
                uniform sampler3D u_coherence_field;
                uniform float u_omega_drive;

                // --- Fundamental Constants ---
                const float PI = 3.14159265359;
                const float PHI = 1.61803398875;

                // --- Ray Marching Parameters ---
                const int MAX_STEPS = 96;
                const float MAX_DIST = 5.0;
                const float STEP_SIZE = 0.03;

                // --- Ray Direction Calculation ---
                vec3 get_ray_dir(vec2 uv, mat4 inv_proj, mat4 inv_view) {
                    vec4 near = vec4(uv, -1.0, 1.0);
                    vec4 far = vec4(uv, 1.0, 1.0);
                    vec4 near_world = inv_view * inv_proj * near;
                    vec4 far_world = inv_view * inv_proj * far;
                    near_world /= near_world.w;
                    far_world /= far_world.w;
                    return normalize(far_world.xyz - near_world.xyz);
                }
                
                // --- HSL to RGB conversion ---
                vec3 hsl2rgb(vec3 c) {
                    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
                    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
                }

                void main() {
                    // --- Moved from global scope to fix initialization error ---
                    mat4 inverse_projection = inverse(u_camera_proj_matrix);
                    mat4 inverse_view = inverse(u_camera_view_matrix);

                    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
                    vec3 ray_dir = get_ray_dir(uv, inverse_projection, inverse_view);
                    vec3 ray_pos = inverse_view[3].xyz;

                    vec4 final_color = vec4(0.0);
                    float total_dist = 0.0;

                    for (int i = 0; i < MAX_STEPS; i++) {
                        if (total_dist >= MAX_DIST || final_color.a > 0.99) break;

                        // Sample the coherence field (ω) at the current position
                        // Map position from [-1, 1] space to [0, 1] texture space
                        float omega = texture(u_coherence_field, ray_pos * 0.5 + 0.5).r;
                        omega = smoothstep(0.0, 1.0, omega);

                        if (omega > 0.01) {
                            // --- Calculate Chaos (χ) and Structure (Σ) ---
                            // We use safe division to avoid issues when omega is near zero
                            float chi = PHI / (PI * max(omega, 0.001)); // Chaotic Potential
                            float sigma = omega * (PI / PHI);            // Structural Information

                            // --- Determine Color and Density from the Duality ---
                            float density = pow(sigma, 2.0) * 20.0; // Structure creates opacity
                            
                            // Chaos determines color and brightness
                            float chaos_energy = pow(chi, 1.5) * 0.05;
                            float hue = mod(u_time * 0.02 + chi * 0.1, 1.0);
                            float saturation = 1.0;
                            float lightness = chaos_energy * u_omega_drive * 0.1;
                            
                            vec3 color = hsl2rgb(vec3(hue, saturation, lightness));

                            // --- Accumulate Color (Volumetric Rendering) ---
                            float alpha = min(1.0, density * STEP_SIZE);
                            final_color.rgb += color * alpha * (1.0 - final_color.a);
                            final_color.a += alpha * (1.0 - final_color.a);
                        }
                        
                        ray_pos += ray_dir * STEP_SIZE;
                        total_dist += STEP_SIZE;
                    }
                    
                    gl_FragColor = vec4(final_color.rgb, final_color.a);
                }
            `,
            transparent: true,
            depthWrite: false,
        });

        const screenQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), shaderMaterial);
        scene.add(screenQuad);

        // --- Compute Shader for updating the coherence field ---
        const computeShaderCode = `
            uniform sampler3D u_coherence_field;
            uniform vec3 u_mouse_pos_3d;
            uniform float u_delta_time;
            uniform bool u_is_mouse_down;

            // This function is the entry point for the compute shader
            void main() {
                // Get the coordinates of the voxel we are processing
                ivec3 texel_coord = ivec3(gl_GlobalInvocationID.xyz);
                
                // Fetch the current coherence value (ω)
                float current_omega = texelFetch(u_coherence_field, texel_coord, 0).r;
                
                // Calculate the voxel's position in world space [-1, 1]
                vec3 world_pos = (vec3(texel_coord) / vec3(textureSize(u_coherence_field, 0))) * 2.0 - 1.0;
                
                // --- Interaction Logic ---
                float dist_to_mouse = distance(world_pos, u_mouse_pos_3d);
                float influence = 0.0;
                if (u_is_mouse_down && dist_to_mouse < 0.3) {
                    // When mouse is down, apply coherence
                    influence = smoothstep(0.3, 0.0, dist_to_mouse) * 1.5;
                }
                
                // --- Decay and Update ---
                // Coherence decays over time, but influence adds to it
                float new_omega = current_omega * (1.0 - 0.5 * u_delta_time) + influence * u_delta_time;
                new_omega = clamp(new_omega, 0.0, 1.0);
                
                // Write the new coherence value back to the texture
                imageStore(u_coherence_field_out, texel_coord, vec4(new_omega, 0.0, 0.0, 0.0));
            }
        `;
        
        // Due to limitations in this environment, a true compute shader isn't possible.
        // We will simulate its effect directly on the CPU. This is less performant but demonstrates the logic.
        const clock = new THREE.Clock();
        const mousePos3D = new THREE.Vector3();

        function updateCoherenceField(deltaTime) {
            const data = coherenceTexture.image.data;
            const size = fieldResolution;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Find the 3D position of the mouse in the simulation space
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            raycaster.ray.intersectPlane(plane, mousePos3D);

            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = x + y * size + z * size * size;
                        const worldX = (x / size) * 2 - 1;
                        const worldY = (y / size) * 2 - 1;
                        const worldZ = (z / size) * 2 - 1;
                        const worldPos = new THREE.Vector3(worldX, worldY, worldZ);
                        
                        const distToMouse = worldPos.distanceTo(mousePos3D);
                        let influence = 0.0;

                        if (isMouseDown && distToMouse < 0.3) {
                             influence = (1.0 - distToMouse / 0.3) * 1.5;
                        }

                        data[i] = data[i] * (1.0 - 0.5 * deltaTime) + influence * deltaTime;
                        data[i] = Math.max(0.0, Math.min(1.0, data[i]));
                    }
                }
            }
            coherenceTexture.needsUpdate = true;
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Update the coherence field based on user input and decay
            updateCoherenceField(deltaTime);
            
            controls.update();
            shaderMaterial.uniforms.u_time.value += deltaTime;
            shaderMaterial.uniforms.u_camera_view_matrix.value = camera.matrixWorldInverse;
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
