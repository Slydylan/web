<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Coherence Multiverse</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            line-height: 1.5;
            max-width: 80%;
            z-index: 10; /* Ensure it's above the canvas */
        }
        #info-title { font-weight: 700; font-size: 22px; color: #ffdf80; }
        #info-description { font-size: 16px; color: #ccc; }


        .back-link {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            text-decoration: none;
            font-family: 'Inter', sans-serif;
            z-index: 10; /* Ensure it's above the canvas */
        }
        .back-link:hover {
            background-color: rgba(0, 0, 0, 0.8);
            border-color: #fff;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info-panel">
        <div id="info-title">Phase I: Initial State</div>
        <div id="info-description">A high population of universe bubbles in a state of potential.</div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';


        // --- Core Simulation Parameters ---
        const NUM_UNIVERSES = 100000; // A large number for "high population"
        const FIELD_SPREAD = 200;    // Initial spread of universes
        const TORUS_MAJOR_RADIUS = 80; // Radius from center of hole to center of tube
        const TORUS_MINOR_RADIUS = 30; // Radius of the tube itself
        const COHERENCE_CASCADE_START_TIME = 5.0; // Seconds into simulation
        const COHERENCE_CASCADE_DURATION = 10.0; // How long the formation takes


        // --- Scene & Simulation State ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 200); // Adjust camera to view the torus
        camera.lookAt(0, 0, 0);


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);


        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;
        controls.minDistance = 50;
        controls.maxDistance = 500;


        const clock = new THREE.Clock();
       
        // --- Particle System Setup ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(NUM_UNIVERSES * 3);
        const colors = new Float32Array(NUM_UNIVERSES * 3);
        const universeStates = []; // Stores current position, target position, and initial random offset


        // --- Initialize Universe Bubbles ---
        for (let i = 0; i < NUM_UNIVERSES; i++) {
            // Initial random spread
            const initialX = (Math.random() - 0.5) * FIELD_SPREAD;
            const initialY = (Math.random() - 0.5) * FIELD_SPREAD;
            const initialZ = (Math.random() - 0.5) * FIELD_SPREAD;


            // Calculate target position on the torus
            // Use two angles (u, v) to map to the torus surface
            const u = Math.random() * Math.PI * 2; // Angle around the main ring
            const v = Math.random() * Math.PI * 2; // Angle around the tube


            const targetX = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(v)) * Math.cos(u);
            const targetY = (TORUS_MAJOR_RADIUS + TORUS_MINOR_RADIUS * Math.cos(v)) * Math.sin(u);
            const targetZ = TORUS_MINOR_RADIUS * Math.sin(v);


            positions[i * 3] = initialX;
            positions[i * 3 + 1] = initialY;
            positions[i * 3 + 2] = initialZ;


            universeStates.push({
                initialPos: new THREE.Vector3(initialX, initialY, initialZ),
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                coherenceFactor: 0 // 0 = initial, 1 = fully coherent
            });
        }


        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));


        const material = new THREE.PointsMaterial({
            size: 0.8, // Slightly larger points for visibility
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });


        const points = new THREE.Points(geometry, material);
        scene.add(points);


        // --- Narrative & State Management ---
        const infoTitle = document.getElementById('info-title');
        const infoDescription = document.getElementById('info-description');
        let currentPhase = 0; // 0: Initial, 1: Cascading, 2: Coherent


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const elapsedTime = clock.getElapsedTime();


            const currentPositions = geometry.attributes.position.array;
            const currentColors = geometry.attributes.color.array;
            const color = new THREE.Color();


            // --- Update Simulation Phase ---
            if (elapsedTime >= COHERENCE_CASCADE_START_TIME && currentPhase === 0) {
                currentPhase = 1; // Start cascade
                infoTitle.textContent = 'Phase II: Coherence Cascade';
                infoDescription.textContent = 'Universe bubbles are drawn into a system-wide, stable structure.';
            } else if (elapsedTime >= COHERENCE_CASCADE_START_TIME + COHERENCE_CASCADE_DURATION && currentPhase === 1) {
                currentPhase = 2; // Fully coherent
                infoTitle.textContent = 'Phase III: High Coherence Multiverse';
                infoDescription.textContent = 'The multiverse has achieved a state of profound, stable order.';
                controls.autoRotateSpeed = 0.05; // Slow down auto-rotation
            }


            // --- Update each Universe Bubble ---
            for (let i = 0; i < NUM_UNIVERSES; i++) {
                const state = universeStates[i];
                let currentPos = new THREE.Vector3(currentPositions[i * 3], currentPositions[i * 3 + 1], currentPositions[i * 3 + 2]);


                if (currentPhase === 1) { // Coherence Cascade in progress
                    const cascadeProgress = (elapsedTime - COHERENCE_CASCADE_START_TIME) / COHERENCE_CASCADE_DURATION;
                    // Smooth interpolation using a sine curve for a natural acceleration/deceleration
                    const easedProgress = 0.5 - 0.5 * Math.cos(cascadeProgress * Math.PI);
                    currentPos.lerpVectors(state.initialPos, state.targetPos, easedProgress);
                    state.coherenceFactor = easedProgress; // Update coherence factor for coloring
                } else if (currentPhase === 2) { // Fully Coherent
                    currentPos.copy(state.targetPos); // Lock to target position
                    state.coherenceFactor = 1.0; // Max coherence
                    // Add subtle breathing/pulsing effect for ongoing coherence
                    const pulse = Math.sin(elapsedTime * 0.5 + i * 0.01) * 0.05; // Slight individual offset
                    currentPos.addScaledVector(currentPos.clone().normalize(), pulse);
                }
                // Else (currentPhase === 0), positions remain at initial random spread


                currentPositions[i * 3] = currentPos.x;
                currentPositions[i * 3 + 1] = currentPos.y;
                currentPositions[i * 3 + 2] = currentPos.z;


                // --- Set Color based on Coherence Factor ---
                // Interpolate from a cool blue/purple to a warm golden/white
                const hueStart = 0.6; // Blue
                const hueEnd = 0.12;  // Golden
                const saturationStart = 0.8;
                const saturationEnd = 1.0;
                const lightnessStart = 0.1;
                const lightnessEnd = 0.9;


                const currentHue = THREE.MathUtils.lerp(hueStart, hueEnd, state.coherenceFactor);
                const currentSaturation = THREE.MathUtils.lerp(saturationStart, saturationEnd, state.coherenceFactor);
                const currentLightness = THREE.MathUtils.lerp(lightnessStart, lightnessEnd, state.coherenceFactor);
               
                color.setHSL(currentHue, currentSaturation, currentLightness);


                currentColors[i * 3] = color.r;
                currentColors[i * 3 + 1] = color.g;
                currentColors[i * 3 + 2] = color.b;
            }


            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;


            renderer.render(scene, camera);
        }


        // --- Handle Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- Add Back Button ---
        const backButton = document.createElement('a');
        backButton.href = 'index.html';
        backButton.textContent = 'Back to Index';
        backButton.className = 'back-link'; // Use a class for styling
        document.body.appendChild(backButton);
       
        // Start the animation
        animate();
    </script>
</body>
</html>



